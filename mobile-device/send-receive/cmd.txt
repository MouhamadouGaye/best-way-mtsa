# Check current versions
npm list react react-dom react-native-renderer

# Update to matching versions (choose one approach):

# Approach 1: Update react-native-renderer to match React 19.2.0
npm install react-native-renderer@19.2.0

# Approach 2: Or downgrade React to match react-native-renderer 19.1.0
npm install react@19.1.0 react-dom@19.1.0

# Approach 3: If using Expo, check compatible versions
expo doctor --fix-dependencies


npm install react-native-vector-icons
npm install @react-navigation/bottom-tabs
# or if using Expo
expo install react-native-vector-icons @react-navigation/bottom-tabs



npm i --save-dev @types/react-native-vector-icons     // when it refuse to work because of the type



more complete request:
private async request<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  // Get auth token from your storage
  const token = localStorage.getItem('authToken') || await yourAsyncStorageMethod();
  
  const headers: HeadersInit = {
    "Content-Type": "application/json",
    ...options.headers,
  };

  // Add authorization header if token exists
  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  const response = await fetch(`${this.baseURL}${endpoint}`, {
    ...options,
    credentials: "include", // This handles cookies
    headers,
  });

  if (!response.ok) {
    // Better error handling
    let errorMessage = "Request failed";
    try {
      const errorData = await response.json();
      errorMessage = errorData.message || errorMessage;
    } catch {
      errorMessage = `HTTP ${response.status}: ${response.statusText}`;
    }
    throw new Error(errorMessage);
  }

  return response.json();
}

// client.ts


  // // Update your ApiService request method
  //  private async request<T>(
  //   endpoint: string,
  //   options: RequestInit = {}
  // ): Promise<T> {
  //   const url = `${this.baseURL}${endpoint}`;
  //   console.log(`Making API request to: ${url}`);

  //   try {
  //     const response = await fetch(url, {
  //       ...options,
  //       credentials: "include",
  //       headers: {
  //         "Content-Type": "application/json",
  //         ...options.headers,
  //       },
  //     });

  //     console.log(`Response status: ${response.status} ${response.statusText}`);

  //     if (!response.ok) {
  //       let errorData;
  //       try {
  //         errorData = await response.json();
  //       } catch {
  //         errorData = { message: (await response.text()) || "Request failed" };
  //       }

  //       console.error(`API Error ${response.status}:`, errorData);
  //       throw new Error(
  //         errorData.message ||
  //           `HTTP ${response.status}: ${response.statusText}` ||
  //           "Request failed"
  //       );
  //     }

  //     const data = await response.json();
  //     console.log("API response data:", data);
  //     return data;
  //   } catch (error: any) {
  //     console.error("Fetch error:", error);
  //     if (error.name === "TypeError" && error.message.includes("fetch")) {
  //       throw new Error("Network error: Cannot connect to server");
  //     }
  //     throw error;
  //   }
  // }
  private async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.baseURL}${endpoint}`;
    console.log(`Making API request to: ${url}`);

    try {
      // Get auth token from your storage
      const token = await this.getAuthToken();

      const headers: Record<string, string> = {
        "Content-Type": "application/json",
      };

      // Merge any provided headers (Headers instance, array, or object) into the plain record
      if (options.headers) {
        if (typeof Headers !== "undefined" && options.headers instanceof Headers) {
          options.headers.forEach((value, key) => {
            headers[key] = value;
          });
        } else if (Array.isArray(options.headers)) {
          (options.headers as [string, string][]).forEach(([key, value]) => {
            headers[key] = value;
          });
        } else {
          Object.assign(headers, options.headers as Record<string, string>);
        }
      }

      // Add authorization header if token exists
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }

      console.log("Request headers:", headers);

      const response = await fetch(url, {
        ...options,
        credentials: "include",
        headers,
      });

      console.log(`Response status: ${response.status} ${response.statusText}`);

      if (!response.ok) {
        // Clone the response before reading it to avoid "Already read" error
        const responseClone = response.clone();
        let errorData;
        try {
          errorData = await responseClone.json();
        } catch {
          try {
            const text = await response.text();
            errorData = { message: text || "Request failed" };
          } catch {
            errorData = {
              message: `HTTP ${response.status}: ${response.statusText}`,
            };
          }
        }

        console.error(`API Error ${response.status}:`, errorData);
        throw new Error(
          errorData.message || `HTTP ${response.status}: ${response.statusText}`
        );
      }

      const data = await response.json();
      console.log("API response data:", data);
      return data;
    } catch (error: any) {
      console.error("Fetch error:", error);
      if (error.name === "TypeError" && error.message.includes("fetch")) {
        throw new Error("Network error: Cannot connect to server");
      }
      throw error;
    }
  }

  private async getAuthToken(): Promise<string | null> {
    // Use whatever storage method you're using
    try {
      // For React Native AsyncStorage
      const token = await AsyncStorage.getItem("authToken");
      // Or for web localStorage
      // const token = localStorage.getItem('authToken');
      return token;
    } catch (error) {
      console.error("Failed to get auth token:", error);
      return null;
    }
  }